// Module included in the following assemblies:
// * about/serverless-logic-overview.adoc


:_content-type: CONCEPT
[id="serverless-logic-overview-custom-functions_{context}"]
= Custom functions

OpenShift Serverless Logic supports the `custom` function type, which enables the implementation to extend the function definitions capability. By combining with the `operation` string, you can use a list of predefined function types. 

[NOTE]
====
Custom function types might not be portable across other runtime implementations.
==== 

[id="sysout-custom-function_{context}"]
== Sysout custom function

You can use the `sysout` function for logging, as shown in the following example:

.Example of `sysout` function definition
[source,json]
----
{
  "functions": [
    {
      "name": "logInfo",
      "type": "custom",
      "operation": "sysout:INFO"
    }
  ]
}
----

The string after the `:` is optional and is used to indicate the log level. The possible values are `TRACE`, `DEBUG`, `INFO`, `WARN`, and `ERROR`. If the value is not present, `INFO` is the default.

In the `state` definition, you can call the same `sysout` function as shown in the following example:

.Example of a `sysout` function reference within a state
[source,json]
----
{
  "states": [
    {
      "name": "myState",
      "type": "operation",
      "actions": [
        {
          "name": "printAction",
          "functionRef": {
            "refName": "logInfo",
            "arguments": {
              "message": "\"Workflow model is \\(.)\""
            }
          }
        }
      ]
    }
  ]
}
----

In the previous example, the `message` argument can be a jq expression or a jq string using interpolation.

[id="java-custom-function_{context}"]
== Java custom function

OpenShift Serverless Logic supports the `java` functions within an Apache Maven project, in which you define your workflow service.

The following example shows the declaration of a `java` function:

.Example of a `java` function declaration
[source,json]
----
{
  "functions": [
    {
      "name": "myFunction", <1>
      "type": "custom", <2>
      "operation": "service:java:com.acme.MyInterfaceOrClass::myMethod" <3>
    }
  ]
}
----

<1> `myFunction` is the function name.
<2> `custom` is the function type.
<3> `service:java:com.acme.MyInterfaceOrClass::myMethod` is the custom operation definition. In the custom operation definition, `service` is the reserved operation keyword, followed by the `java` keyword. `com.acme.MyInterfaceOrClass` is the FQCN (Fully Qualified Class Name) of the interface or implementation class, followed by the method name `myMethod`.

//[id="camel-custom-function_{context}"] (I have commented out this section, as we have discussed with the Dev team to add this post-release)
//== Camel custom function
//OpenShift Serverless Logic supports the Camel Routes functions within an Apache Maven project, in which you define your workflow service.
//The following example shows the declaration of a `Camel` function:

//.Example of a `Camel` function declaration
//[source,json]
//----
//{
//  "functions": [
//    {
//      "name": "myCamelEndpoint", <1>
//      "type": "custom", <2>
//      "operation": "camel:direct:myendpoint" <3>
//    }
//  ]
//}
//----

//<1> `myCamelEndpoint` is the function name.
//<2> `custom` is the function type.
//<3> `camel:direct:myendpoint` is the custom operation definition. In this definition, `camel` is the reserved keyword followed by the direct endpoint, and `myendpoint` is the endpoint URI name found in the route within your project.

[id="knative-custom-function_{context}"]
== Knative custom function

OpenShift Serverless Logic provides an implementation of a custom function through the `knative-serving` add-on to invoke Knative services. It allows you to have a static URI, defining a Knative service, that is used to perform HTTP requests. The Knative service defined in the URI is queried in the current Knative cluster and translated to a valid URL.

The following example uses a deployed Knative service:

[source,bash]
----
$ kn service list
NAME                              URL                                                                      LATEST                                  AGE     CONDITIONS   READY   REASON
custom-function-knative-service   http://custom-function-knative-service.default.10.109.169.193.sslip.io   custom-function-knative-service-00001   3h16m   3 OK / 3     True
----

You can declare a OpenShift Serverless Logic custom function using the Knative service name, as shown in the following example:
[source,json]
----
  "functions": [
    {
      "name": "greet", <1>
      "type": "custom", <2>
      "operation": "knative:services.v1.serving.knative.dev/custom-function-knative-service?path=/plainJsonFunction", <3>
    }
  ]
----

<1> `greet` is the function name.
<2> `custom` is the function type.
<3> In `operation`, you set the coordinates of the Knative service.

[NOTE]
====
This function sends a `POST` request. If you do not specify a path, OpenShift Serverless Logic uses the root path (/). You can also send `GET` requests by setting `method=GET` in the operation. In this case, the arguments are forwarded over a query string.
====

[id="rest-custom-function_{context}"]
== REST custom function

OpenShift Serverless Logic offers the `REST` custom type as a shortcut. When using custom rest, in the function definition, you specify the HTTP URI to be invoked and the HTTP method (get, post, patch, or put) to be used. This is done by using the `operation` string. When the function is invoked, you pass the request arguments as you do when using an OpenAPI function. 

The following example shows the declaration of a `rest` function:

[source,json]
----
  {
  "functions": [
    {
      "name": "multiplyAllByAndSum", <1>
      "type": "custom", <2>
      "operation": "rest:post:/numbers/{multiplier}/multiplyByAndSum" <3>
    }
  ]
}
----

<1> `multiplyAllAndSum` is the function name.
<2> `custom` is the function type.
<3> `rest:post:/numbers/{multiplier}/multiplyByAndSum` is the custom operation definition. In the custom operation definition, `rest` is the reserved operation keyword that indicates this is a REST call, `post` is the HTTP method, and `/numbers/{multiplier}/multiplyByAndSum` is the relative endpoint.

When using the relative endpoints, you must specify the host as a property. The format of the host property is `kogito.sw.functions.<function_name>`.host. In this example, `kogito.sw.functions.multiplyAllByAndSum.host` is the host property key. You can override the default port (80) if needed by specifying the `kogito.sw.functions.multiplyAllAndSum.port` property.

This endpoint expects as body a JSON object whose field `numbers` is an array of integers, multiplies each item in the array by `multiplier` and returns the sum of all the multiplied items.