// Module included in the following assemblies:
//
// * knative-serving/serving-transport-encryption.adoc
:_mod-docs-content-type: CONCEPT
[id="serving-transport-encryption-trust-configuration_{context}"]
= Trust configuration

When you enable any of the transport encryption features, you must make sure that all clients calling trust the Certificate Authority (CA) issuing the certificates used for the transport encryption.

There are multiple places where trust must be ensured:

* Cluster external client, such as Browser or other application. This is out of the scope of {ServerlessProductName}.

* {ServerlessProductName} system components, such as Activator, Queue-Proxy, and Ingress-Controller.

* Cluster internal client, such as a Knative Service or other workload.


[id="serving-transport-encryption-trust-configuration-serving-and-services_{context}"]
== Trust configuration for OpenShift Serverless Serving components and Knative Services

To ensure that {ServerlessProductName} Serving components and Knative Services trust the CA that issues certificates, you can create a ConfigMap in the following namespaces with the label `networking.knative.dev/trust-bundle: true`:

--
`knative-serving`:: for the system components of {ServerlessProductName} Serving.
`knative-serving-ingress`:: for the ingress layer of {ServerlessProductName} Serving.
`istio-system` or your own {SMProductShortName} namespace:: when the {SMProductShortName} integration is enabled.
--

Knative reads all data keys in ConfigMaps with this label, regardless of the name. One key can contain one or multiple CAs or intermediate certificates. If they are valid, they are added to the trust store of the Knative components.

This is an example ConfigMap:

[source,yaml]
----
apiVersion: v1
data:
  cacerts.pem: | <1>
    -----BEGIN CERTIFICATE-----
    MIIDDTCCAfWgAwIBAgIQMQuip05h7NLQq2TB+j9ZmTANBgkqhkiG9w0BAQsFADAW
    MRQwEgYDVQQDEwtrbmF0aXZlLmRldjAeFw0yMzExMjIwOTAwNDhaFw0yNDAyMjAw
    OTAwNDhaMBYxFDASBgNVBAMTC2tuYXRpdmUuZGV2MIIBIjANBgkqhkiG9w0BAQEF
    AAOCAQ8AMIIBCgKCAQEA3clC3CV7sy0TpUKNuTku6QmP9z8JUCbLCPCLACCUc1zG
    FEokqOva6TakgvAntXLkB3TEsbdCJlNm6qFbbko6DBfX6rEggqZs40x3/T+KH66u
    4PvMT3fzEtaMJDK/KQOBIvVHrKmPkvccUYK/qWY7rgBjVjjLVSJrCn4dKaEZ2JNr
    Fd0KNnaaW/dP9/FvviLqVJvHnTMHH5qyRRr1kUGTrc8njRKwpHcnUdauiDoWRKxo
    Zlyy+MhQfdbbyapX984WsDjCvrDXzkdGgbRNAf+erl6yUm6pHpQhyFFo/zndx6Uq
    QXA7jYvM2M3qCnXmaFowidoLDsDyhwoxD7WT8zur/QIDAQABo1cwVTAOBgNVHQ8B
    Af8EBAMCAgQwEwYDVR0lBAwwCgYIKwYBBQUHAwEwDwYDVR0TAQH/BAUwAwEB/zAd
    BgNVHQ4EFgQU7p4VuECNOcnrP9ulOjc4J37Q2VUwDQYJKoZIhvcNAQELBQADggEB
    AAv26Vnk+ptQrppouF7yHV8fZbfnehpm07HIZkmnXO2vAP+MZJDNrHjy8JAVzXjt
    +OlzqAL0cRQLsUptB0btoJuw23eq8RXgJo05OLOPQ2iGNbAATQh2kLwBWd/CMg+V
    KJ4EIEpF4dmwOohsNR6xa/JoArIYH0D7gh2CwjrdGZr/tq1eMSL+uZcuX5OiE44A
    2oXF9/jsqerOcH7QUMejSnB8N7X0LmUvH4jAesQgr7jo1JTOBs7GF6wb+U76NzFa
    8ms2iAWhoplQ+EHR52wffWb0k6trXspq4O6v/J+nq9Ky3vC36so+G1ZFkMhCdTVJ
    ZmrBsSMWeT2l07qeei2UFRU=
    -----END CERTIFICATE-----
kind: ConfigMap
metadata:
  labels:
    networking.knative.dev/trust-bundle: "true"
  name: knative-bundle <2>
  namespace: knative-serving
----
<1> Serving components trust all keys containing valid PEM-encoded CA bundles.
<2> You can use an arbitrary name.

[IMPORTANT]
====
When a CA bundle ConfigMap is created or updated, the Serving components automatically pick them up and add the CAs or intermediate certificates to their CA trust store. The trust store is refreshed for every new HTTP connection.
====

[id="serving-transport-encryption-trust-configuration-custom-workload_{context}"]
== Trust configuration on your custom workload

As {ServerlessProductName} Serving does not control all workloads and managing trust is highly dependent on your runtime and language, custom workloads are out of the scope of {ServerlessProductName}. The following are other options for custom workloads:

* Adding a CA bundle to a Container image on build-time. Note that this complicates CA rotation, as you must rebuild and redeploy every application when the CA rotates.

* Mounting a CA bundle to the filesystem, such as from a Secret or ConfigMap, and making sure your application uses it to verify TLS connections.

* Reading a CA bundle from an environment variable and making sure that your application uses it to verify TLS connections.

* Accessing a CA bundle from a secret or ConfigMap using Kubernetes API and making sure your application uses it to verify TLS connections.
